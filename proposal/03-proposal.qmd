# The proposal

<!--
How are you going to solve the problem? Include the concrete actions you
will take and an estimated timeline. What are likely failure modes and
how will you recover from them?

This is where the proposal should be outlined.
-->

## Overview

<!--
At a high-level address what your proposal is and how it will address
the problem identified. Highlight any benefits to the R Community that
follow from solving the problem. This should be your most compelling
section.

Include concrete actions you will take and estimated timeline.
-->

R's interactive prompt is the bedrock of R as an analytic language, allowing for
experimentation in the context of code without long compilation steps and
static scripts. A central part of this workflow is the debugger, which is 
provided with the language and allows for exceptionally dynamic interruption,
modification and experimentation with code as it is running.

Despite R's long standing support for interactive debugging, the user experience
has not changed significantly, largely resembling the debug experience of
Common Lisp. Until recently, it has been difficult to build custom tooling
around the existing R debugging experience. The introduction of _browser hooks_,
specifically, have provided a mechanism to inject additional code which can
allow for arbitrarily complex actions to be taken during debugging. These tools
offer the possibility of overcoming some of the challenges of introspecting the
debug frame that have had to be painstakingly engineered around in projects such
as `vscDebugger` and `ark`, requiring a wrapping process that attempts to
extract information from command-line output or an overseer that manages
communication between an R process and DAP server.

We are uniquely positioned to test new R features and provide active feedback to
the R Core to drive the debugging experience forward. We plan to implement an
R-native debug adapter server that is truly IDE agnostic while improving on the
user experience by leveraging recent R enhancements related to the `browser()`.

We plan to implement a debugger experience that extends the R `browser()` to the
IDE, mirroring state and allowing for interaction through either interface. When
implemented, a user may:

1. Use an IDE for standard debugging operations, such as setting breakpoints
   and stepping through code.
2. Step through the code in a running R Session, reflecting the debugger status
   in the IDE.
3. Inspect the debug frame from the IDE, or in a running R session.
4. Use a stateful R Session when debugging, allowing, for example, masked
   functions, variables and search path modification during debugging, in a way
   that is similar to the familiar browser prompt.
5. Use the DAP with any IDE that supports the protocol.
6. Install the DAP as an R package for easier distribution.
7. Build the DAP R package with minimal system dependencies.

<!--
TODO:
  - timeline
-->

## Detail

<!--
Go into more detail about the specifics of the project and how it delivers
against the problem.

Depending on project type the detail section should include:
-->

### Minimum Viable Product

<!--
What is the smallest thing you can build that delivers value to your users?
-->

Although our goal is to explore the limitations of a full DAP implementation
in R, providing a _useful_ R-native DAP server is well within reach.

`debugadapter` [@debugadapter] initially hit two major roadblocks that prevented
the implementation of central DAP features. First, the DAP server should run in
the background so that it remains responsive as the user continues to interact
with the prompt. Second, it should hook into the `browser()` prompt to emit DAP
messages. Both of these initial roadblocks have actionable paths forward.

While the initial architecture was quite complicated, this design can be
drastically simplified. The first challenge can be overcome by using the `later`
package to continue to synchronize the IDEs debugger state while the R prompt
idles. Initial tests have been promising, suggesting that this might provide a
vehicle for cutting out one stop of the DAP message relay. The second challenge
has been reasonably addressed through the features exposed through the
`USE_BROWSER_HOOK` compilation flag. 

A minimum viable product would require:

1. A rewrite of the DAP server to run in the background using `later`, instead
   of as a separate R process that relays messages. This will make the 
   architecture far simpler and provide a mechanism of accessing the user's
   existing environment within the debug frame.
2. Implement a _manual_ synchronization command that can be used in lieu of
   R `devel`s `USE_BROWSER_HOOK`, which would also serve to make these features
   release-ready should this flag be enabled by default in the future.

### Architecture

<!--
What does the high-level architecture look like?
-->

The majority of the DAP protocol itself is clearly specified. Because R
provides a level of interactivity that isn't clearly defined within the scope of
the DAP, some design details are left open for interpretation.

As a proposal, we plan to design an architecture that has uses:

1. A running R process, which manages interaction with a DAP server using a
   `{later}` loop, executed periodically while the R process is idle.
2. A background process, which serves as a message relay and buffer. This
   background process allows us to immediately respond to DAP queries so that
   the IDEs debugger functionality isn't stalled (or timing-out) while waiting
   for the R session to idle and respond. This component isn't strictly
   necessary, and a minimum viable product need not include it, but the user
   experience would suffer as an IDE would report response timeout errors.

```{mermaid}
%%| label: attach-mode-diagram
%%| fig-cap: |
%%|   **Figure:** A specialized architecture for an _attach mode_ DAP server.
%%|   Note that an alternative _launch mode_ server would leverage many of the
%%|   same components, differentiated only in that it doesn't attach to an
%%|   existing R session.

---
displayMode: compact
---

sequenceDiagram

participant user as User
participant ide  as Client <br> (IDE)
participant dap  as DAP Server Proxy <br> (Message Buffer)
participant r    as R Prompt <br> (Console)

user->>ide: User starts IDE
ide->>r: IDE launches R Session
r->>dap: .Rprofile <br> `debugadapter::run()`

loop User REPL session
  ide->>+r: Read
  r->>-ide: Evaluate, Print
end

user->>ide: User sets breakpoint
ide->>+dap: request attach
dap->>+r: request session capabilities
r->>-dap: respond session capabilities
dap->>-ide: respond attach confirmation

loop `{later}` or `browser()` callbacks
    ide-->>+dap: listen for updates
    dap-->>+r: request session information
    r-->>-dap: reply session information
    dap-->>-ide: reply

    opt browser() callback via options("browser.hook")
        r->>+dap: send debug state
        dap->>-ide: update debug state
    end
end
```

### Assumptions

<!--
What assumptions are you making that, if proven false, would invalidate the project?
-->

There are no assumptions that would entirely invalidate this project, though
there are assumptions which may limit its impact:

1. To make this work most effective, we hope that there is interest in the R
   Core for continuing to support and stabilize browser hooks.
2. We assume that `ark` continues to be limited by base R capabilities to
   permit effective breakpoint injection, and that our development here would
   help pave the way for both projects.
3. We assume that `ark` intends to continue being shipped as a standalone
   binary, requiring that users go beyond a simple package install to enable
   a debugger, leaving a gap for a more canonically installed R extension.
4. We assume that `ark` will continue to be provided as a combined Jupyter
   Kernel and DAP implementation, making it less accessible to IDEs beyond
   Positron.
5. We assume that the goals of `vscDebugger` continue to prioritize VSCode,
   leaving a gap for a more agnostic solution.

### External dependencies

<!--
What external dependencies does the project have (e.g. libraries, services, other projects, etc.)?
-->

- To improve the user experience, we plan to depend on R built with the
  `USE_BROWSER_HOOKS` flag enabled, allowing us to inject code when a browser
  prompt is hit. Without this feature, users may need to manually synchronize
  their debug state.
- `{later}`, to facilitate arbitrary code execution while the user's R session
  idles, allowing us to synchronize debug state without user interaction.
- `vscDebugger` and `ark`, though not dependencies, are similar projects and we
  plan to make sure any learnings from our project are distributed to these
  similar projects.

