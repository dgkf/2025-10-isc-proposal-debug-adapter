# The proposal

<!--
How are you going to solve the problem? Include the concrete actions you
will take and an estimated timeline. What are likely failure modes and
how will you recover from them?

This is where the proposal should be outlined.
-->

## Overview

<!--
At a high-level address what your proposal is and how it will address
the problem identified. Highlight any benefits to the R Community that
follow from solving the problem. This should be your most compelling
section.

Include concrete actions you will take and estimated timeline.
-->

R's interactive prompt is the bedrock of R as an analytic language, allowing for
experimentation in the context of code without long compilation steps and
static scripts. A central part of this workflow is the debugger, which is 
provided with the language and allows for exceptionally dynamic interruption,
modification and experimentation with code as it is running.

Despite R's long standing support for interactive debugging, the user experience
has not changed significantly, largely resembling the debug experience of
Common Lisp. Although improving, it remains difficult to build custom tooling
around the existing R debugging experience. The introduction of _browser hooks_,
specifically, have provided a mechanism to inject additional code which can
allow for arbitrarily complex actions to be taken during debugging. These tools
offer the possibility of overcoming some of the challenges of introspecting the
debug frame that have had to be painstakingly engineered around in projects such
as `vscDebugger` and `ark`, requiring a wrapping process that attempts to
extract information from command-line output or an overseer that manages
communication between an R process and DAP server.

We are uniquely positioned to test new R features and provide active feedback to
the R Core to drive the debugging experience forward. We plan to implement an
R-native debug adapter server that is truly IDE agnostic while improving on the
user experience by leveraging recent R enhancements related to the `browser()`.

## Detail

<!--
Go into more detail about the specifics of the project and how it delivers
against the problem.

Depending on project type the detail section should include:
-->

We plan to implement a debugger experience that extends the R `browser()` to the
IDE, mirroring state and allowing for interaction through either interface. When
implemented, a user may:

1. Use an IDE for standard debugging operations, such as setting breakpoints
   and stepping through code.
2. Step through the code in a running R Session, reflecting the debugger status
   in the IDE.
3. Inspect the debug frame from the IDE, or in a running R session.
4. Use a stateful R Session when debugging, allowing, for example, masked
   functions, variables and search path modification during debugging, in a way
   that is similar to the familiar browser prompt.
5. Use the DAP with any IDE that supports the protocol.
6. Install the DAP as an R package for easier distribution.
7. Build the DAP R package with minimal system dependencies.

We expect that this will require contributions to the R language itself, which we
plan to first implement as a standalone, patched version of R with minimal changes
in support of piloting the proposed capabilities. To proove the utility of these
capabilities, we will develop a user-facing R package that implements a DAP server.

### Minimum Viable Product

<!--
What is the smallest thing you can build that delivers value to your users?
-->

Although our goal is to explore the limitations of a full DAP implementation
in R, providing a _useful_ R-native DAP server is well within reach.

`debugadapter` [@debugadapter] initially hit four major roadblocks that prevented
the implementation of central DAP features.

- First, the DAP server should run in the background so that it remains
responsive as the user continues to interact with the prompt. This challenge has
been largely resolved by a transition to using the `later` package's event loop
to handle messages in the background.
- Second, it should hook into the `browser()` prompt to emit DAP messages.
This has been largely solved by use of the `browser.hook` option in R's devel
version.
- Third, that existing browser hooks require cumbersome acrobatics to
effectively tease out all the necessary debugging information at the appropriate
time. <!-- TODO: more detail --> 
- Fourth, many breakpoints are difficult to set given that many copies of
functions exist throughout an active R session and that not all code has proper
source references.

A minimum viable product would require:

1. That a DAP hosted in a user's R process be able to handle DAP messages even
   while R is idling. We plan to use `later` to continue listening for messages.
2. Use the existing `browser.hook` to handle as much of the DAP protocol as
   possible.
3. Identify gaps that are either untennable or overly complicated to implement
   using only the existing `browser.hook`.

We expect to additionally deliver:

1. A mapping of the DAP protocol to the appropriate place in the `browser()` REPL
   where we would ideally be able to provide protocol responses.
2. A patched version of R that exposes hooks for executing code at these critical
   points.
3. An implementation of a DAP server as an R package to pilot these R internal
   changes.

Beyond our expectations, next steps would include:

1. Further developing the patched version of R to expose C-level callbacks in
   addition to R-level hooks.
2. Exploration of ways that R may internally help to manage an R session's set
   breakpoints.
3. R internal support for breakpoints that affect code without a known source
   reference.
4. Additional options for customizing the browser prompt text (ie, `Browse>`)
   allowing for more informative messaging to the user to indicate when code
   is executing or paused at a breakpoint.

### Architecture

<!--
What does the high-level architecture look like?
-->

The majority of the DAP protocol itself is clearly specified. Because R
provides a level of interactivity that isn't clearly defined within the scope of
the DAP, some design details are left open for interpretation.

We plan to build a DAP server, whose architecture relies on the following core
features:

1. A running, interactive R session, which manages interaction with a
   DAP server using a `{later}` loop, executed periodically while the R process
   is idle. We aim to make this transparent to a user, who may wish to start
   the DAP listener on startup as part of a `.RProfile`.
2. Various additional browser hooks, implemented as part of the R language, which
   can support retrieval of the breadth of the DAP request data.
3. Various R callback functions which hook into the `browser()` REPL's loop
   to listen and respond to DAP client requests.

These central pieces would amount to a native R DAP server implementation, which
run in the background of a user-facing interactive R session. Our hope is that
this allows for an experience akin to R's native `browser()` prompt, but with all
the visual elements communicated through the supported UI of a user's preferred
IDE.

```{mermaid}
%%| label: attach-mode-diagram
%%| fig-cap: |
%%|   **Figure:** A specialized architecture for an _attach mode_ DAP server.
%%|   Note that an alternative _launch mode_ server would leverage many of the
%%|   same components, differentiated only in that it doesn't attach to an
%%|   existing R session.

---
displayMode: compact
---

sequenceDiagram

participant user as User
participant ide  as Client <br> (IDE)
participant dap  as DAP Server Proxy <br> (Message Buffer)
participant r    as R Prompt <br> (Console)

user->>ide: User starts IDE
ide->>r: IDE launches R Session
r->>dap: .Rprofile <br> `debugadapter::run()`

loop User REPL session
  ide->>+r: Read
  r->>-ide: Evaluate, Print
end

user->>ide: User sets breakpoint
ide->>+dap: request attach
dap->>+r: request session capabilities
r->>-dap: respond session capabilities
dap->>-ide: respond attach confirmation

loop `{later}` or `browser()` callbacks
    ide-->>+dap: listen for updates
    dap-->>+r: request session information
    r-->>-dap: reply session information
    dap-->>-ide: reply

    opt browser() callback via options("browser.hook")
        r->>+dap: send debug state
        dap->>-ide: update debug state
    end
end
```

### Assumptions

<!--
What assumptions are you making that, if proven false, would invalidate the project?
-->

There are no assumptions that would entirely invalidate this project, though
there are assumptions which may limit its impact:

1. To make this work most effective, we hope that there is interest in the R
   Core for continuing to support and stabilize browser hooks.
2. We assume that `ark` continues to be limited by base R capabilities to
   permit effective breakpoint injection, and that our development here would
   help pave the way for both projects.
3. We assume that `ark` intends to continue being shipped as a standalone
   binary, requiring that users go beyond a simple package install to enable
   a debugger, leaving a gap for an implemntation as a more conventionally
   distributed R extension.
4. We assume that `ark` will continue to be provided as a combined Jupyter
   Kernel and DAP implementation, making it less accessible to IDEs beyond
   Positron, or limited by adoption of this protocol.
5. We assume that the goals of `vscDebugger` continue to prioritize VSCode,
   leaving a gap for a more agnostic solution.

### External dependencies

<!--
What external dependencies does the project have (e.g. libraries, services, other projects, etc.)?
-->

- To improve the user experience, we plan to depend on R built with the
  `USE_BROWSER_HOOKS` flag enabled, allowing us to inject code when a browser
  prompt is hit. Without this feature, users may need to manually synchronize
  their debug state.
- `{later}`, to facilitate arbitrary code execution while the user's R session
  idles, allowing us to synchronize debug state without user interaction.
- `vscDebugger` and `ark`, though not dependencies, are similar projects and we
  plan to make sure any learnings from our project are distributed to these
  similar projects.

